// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using MauiReactor.Animations;
using MauiReactor.Shapes;
using MauiReactor.Internals;

#nullable enable
namespace MauiReactor;
public partial interface ISlider : IView
{
    EventCommand<ValueChangedEventArgs>? ValueChangedEvent { get; set; }

    EventCommand<EventArgs>? DragStartedEvent { get; set; }

    EventCommand<EventArgs>? DragCompletedEvent { get; set; }
}

public partial class Slider<T> : View<T>, ISlider where T : Microsoft.Maui.Controls.Slider, new()
{
    public Slider(Action<T?>? componentRefAction = null) : base(componentRefAction)
    {
        SliderStyles.Default?.Invoke(this);
    }

    EventCommand<ValueChangedEventArgs>? ISlider.ValueChangedEvent { get; set; }

    EventCommand<EventArgs>? ISlider.DragStartedEvent { get; set; }

    EventCommand<EventArgs>? ISlider.DragCompletedEvent { get; set; }

    partial void OnBeginAnimate();
    partial void OnEndAnimate();
    protected override void OnThemeChanged()
    {
        if (ThemeKey != null && SliderStyles.Themes.TryGetValue(ThemeKey, out var styleAction))
        {
            styleAction(this);
        }

        base.OnThemeChanged();
    }

    partial void OnAttachingNativeEvents();
    partial void OnDetachingNativeEvents();
    private EventCommand<ValueChangedEventArgs>? _executingValueChangedEvent;
    private EventCommand<EventArgs>? _executingDragStartedEvent;
    private EventCommand<EventArgs>? _executingDragCompletedEvent;
    protected override void OnAttachNativeEvents()
    {
        var nativeControl = NativeControl.EnsureNotNull();
        var thisAsISlider = (ISlider)this;
        if (thisAsISlider.ValueChangedEvent != null)
        {
            nativeControl.ValueChanged += NativeControl_ValueChanged;
        }

        if (thisAsISlider.DragStartedEvent != null)
        {
            nativeControl.DragStarted += NativeControl_DragStarted;
        }

        if (thisAsISlider.DragCompletedEvent != null)
        {
            nativeControl.DragCompleted += NativeControl_DragCompleted;
        }

        OnAttachingNativeEvents();
        base.OnAttachNativeEvents();
    }

    private void NativeControl_ValueChanged(object? sender, ValueChangedEventArgs e)
    {
        var thisAsISlider = (ISlider)this;
        if (_executingValueChangedEvent == null || _executingValueChangedEvent.IsCompleted)
        {
            _executingValueChangedEvent = thisAsISlider.ValueChangedEvent;
            _executingValueChangedEvent?.Execute(sender, e);
        }
    }

    private void NativeControl_DragStarted(object? sender, EventArgs e)
    {
        var thisAsISlider = (ISlider)this;
        if (_executingDragStartedEvent == null || _executingDragStartedEvent.IsCompleted)
        {
            _executingDragStartedEvent = thisAsISlider.DragStartedEvent;
            _executingDragStartedEvent?.Execute(sender, e);
        }
    }

    private void NativeControl_DragCompleted(object? sender, EventArgs e)
    {
        var thisAsISlider = (ISlider)this;
        if (_executingDragCompletedEvent == null || _executingDragCompletedEvent.IsCompleted)
        {
            _executingDragCompletedEvent = thisAsISlider.DragCompletedEvent;
            _executingDragCompletedEvent?.Execute(sender, e);
        }
    }

    protected override void OnDetachNativeEvents()
    {
        var nativeControl = NativeControl;
        if (nativeControl != null)
        {
            nativeControl.ValueChanged -= NativeControl_ValueChanged;
            nativeControl.DragStarted -= NativeControl_DragStarted;
            nativeControl.DragCompleted -= NativeControl_DragCompleted;
        }

        OnDetachingNativeEvents();
        base.OnDetachNativeEvents();
    }

    partial void Migrated(VisualNode newNode);
    protected override void OnMigrated(VisualNode newNode)
    {
        if (newNode is Slider<T> @slider)
        {
            if (_executingValueChangedEvent != null && !_executingValueChangedEvent.IsCompleted)
            {
                @slider._executingValueChangedEvent = _executingValueChangedEvent;
            }

            if (_executingDragStartedEvent != null && !_executingDragStartedEvent.IsCompleted)
            {
                @slider._executingDragStartedEvent = _executingDragStartedEvent;
            }

            if (_executingDragCompletedEvent != null && !_executingDragCompletedEvent.IsCompleted)
            {
                @slider._executingDragCompletedEvent = _executingDragCompletedEvent;
            }
        }

        Migrated(newNode);
        base.OnMigrated(newNode);
    }
}

public partial class Slider : Slider<Microsoft.Maui.Controls.Slider>
{
    public Slider(Action<Microsoft.Maui.Controls.Slider?>? componentRefAction = null) : base(componentRefAction)
    {
    }

    public Slider(params IEnumerable<VisualNode?>? children)
    {
        if (children != null)
        {
            this.AddChildren(children);
        }
    }
}

public static partial class SliderExtensions
{
    public static T Minimum<T>(this T slider, double minimum, RxDoubleAnimation? customAnimation = null)
        where T : ISlider
    {
        //slider.Minimum = minimum;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MinimumProperty, minimum);
        slider.AppendAnimatable(Microsoft.Maui.Controls.Slider.MinimumProperty, customAnimation ?? new RxDoubleAnimation(minimum));
        return slider;
    }

    public static T Minimum<T>(this T slider, Func<double> minimumFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MinimumProperty, new PropertyValue<double>(minimumFunc, componentWithState));
        return slider;
    }

    public static T Maximum<T>(this T slider, double maximum, RxDoubleAnimation? customAnimation = null)
        where T : ISlider
    {
        //slider.Maximum = maximum;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MaximumProperty, maximum);
        slider.AppendAnimatable(Microsoft.Maui.Controls.Slider.MaximumProperty, customAnimation ?? new RxDoubleAnimation(maximum));
        return slider;
    }

    public static T Maximum<T>(this T slider, Func<double> maximumFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MaximumProperty, new PropertyValue<double>(maximumFunc, componentWithState));
        return slider;
    }

    public static T Value<T>(this T slider, double value, RxDoubleAnimation? customAnimation = null)
        where T : ISlider
    {
        //slider.Value = value;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ValueProperty, value);
        slider.AppendAnimatable(Microsoft.Maui.Controls.Slider.ValueProperty, customAnimation ?? new RxDoubleAnimation(value));
        return slider;
    }

    public static T Value<T>(this T slider, Func<double> valueFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ValueProperty, new PropertyValue<double>(valueFunc, componentWithState));
        return slider;
    }

    public static T MinimumTrackColor<T>(this T slider, Microsoft.Maui.Graphics.Color minimumTrackColor)
        where T : ISlider
    {
        //slider.MinimumTrackColor = minimumTrackColor;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MinimumTrackColorProperty, minimumTrackColor);
        return slider;
    }

    public static T MinimumTrackColor<T>(this T slider, Func<Microsoft.Maui.Graphics.Color> minimumTrackColorFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MinimumTrackColorProperty, new PropertyValue<Microsoft.Maui.Graphics.Color>(minimumTrackColorFunc, componentWithState));
        return slider;
    }

    public static T MaximumTrackColor<T>(this T slider, Microsoft.Maui.Graphics.Color maximumTrackColor)
        where T : ISlider
    {
        //slider.MaximumTrackColor = maximumTrackColor;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MaximumTrackColorProperty, maximumTrackColor);
        return slider;
    }

    public static T MaximumTrackColor<T>(this T slider, Func<Microsoft.Maui.Graphics.Color> maximumTrackColorFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.MaximumTrackColorProperty, new PropertyValue<Microsoft.Maui.Graphics.Color>(maximumTrackColorFunc, componentWithState));
        return slider;
    }

    public static T ThumbColor<T>(this T slider, Microsoft.Maui.Graphics.Color thumbColor)
        where T : ISlider
    {
        //slider.ThumbColor = thumbColor;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbColorProperty, thumbColor);
        return slider;
    }

    public static T ThumbColor<T>(this T slider, Func<Microsoft.Maui.Graphics.Color> thumbColorFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbColorProperty, new PropertyValue<Microsoft.Maui.Graphics.Color>(thumbColorFunc, componentWithState));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Microsoft.Maui.Controls.ImageSource thumbImageSource)
        where T : ISlider
    {
        //slider.ThumbImageSource = thumbImageSource;
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, thumbImageSource);
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Func<Microsoft.Maui.Controls.ImageSource> thumbImageSourceFunc, IComponentWithState? componentWithState = null)
        where T : ISlider
    {
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, new PropertyValue<Microsoft.Maui.Controls.ImageSource>(thumbImageSourceFunc, componentWithState));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, string file)
        where T : ISlider
    {
        //slider.ThumbImageSource = Microsoft.Maui.Controls.ImageSource.FromFile(file);
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, Microsoft.Maui.Controls.ImageSource.FromFile(file));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Func<string> action)
        where T : ISlider
    {
        /*slider.ThumbImageSource = new PropertyValue<Microsoft.Maui.Controls.ImageSource>(
            () => Microsoft.Maui.Controls.ImageSource.FromFile(action()));*/
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, new PropertyValue<Microsoft.Maui.Controls.ImageSource>(() => Microsoft.Maui.Controls.ImageSource.FromFile(action())));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, string resourceName, Assembly sourceAssembly)
        where T : ISlider
    {
        //slider.ThumbImageSource = Microsoft.Maui.Controls.ImageSource.FromResource(resourceName, sourceAssembly);
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, Microsoft.Maui.Controls.ImageSource.FromResource(resourceName, sourceAssembly));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Uri imageUri)
        where T : ISlider
    {
        //slider.ThumbImageSource = Microsoft.Maui.Controls.ImageSource.FromUri(imageUri);
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, Microsoft.Maui.Controls.ImageSource.FromUri(imageUri));
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Uri imageUri, bool cachingEnabled, TimeSpan cacheValidity)
        where T : ISlider
    {
        //slider.ThumbImageSource = new Microsoft.Maui.Controls.UriImageSource
        //{
        //    Uri = imageUri,
        //    CachingEnabled = cachingEnabled,
        //    CacheValidity = cacheValidity
        //};
        var newValue = new Microsoft.Maui.Controls.UriImageSource
        {
            Uri = imageUri,
            CachingEnabled = cachingEnabled,
            CacheValidity = cacheValidity
        };
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, newValue);
        return slider;
    }

    public static T ThumbImageSource<T>(this T slider, Func<Stream> imageStream)
        where T : ISlider
    {
        //slider.ThumbImageSource = Microsoft.Maui.Controls.ImageSource.FromStream(imageStream);
        slider.SetProperty(Microsoft.Maui.Controls.Slider.ThumbImageSourceProperty, Microsoft.Maui.Controls.ImageSource.FromStream(imageStream));
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Action? valueChangedAction)
        where T : ISlider
    {
        slider.ValueChangedEvent = new SyncEventCommand<ValueChangedEventArgs>(execute: valueChangedAction);
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Action<ValueChangedEventArgs>? valueChangedAction)
        where T : ISlider
    {
        slider.ValueChangedEvent = new SyncEventCommand<ValueChangedEventArgs>(executeWithArgs: valueChangedAction);
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Action<object?, ValueChangedEventArgs>? valueChangedAction)
        where T : ISlider
    {
        slider.ValueChangedEvent = new SyncEventCommand<ValueChangedEventArgs>(executeWithFullArgs: valueChangedAction);
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Func<Task>? valueChangedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.ValueChangedEvent = new AsyncEventCommand<ValueChangedEventArgs>(execute: valueChangedAction, runInBackground);
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Func<ValueChangedEventArgs, Task>? valueChangedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.ValueChangedEvent = new AsyncEventCommand<ValueChangedEventArgs>(executeWithArgs: valueChangedAction, runInBackground);
        return slider;
    }

    public static T OnValueChanged<T>(this T slider, Func<object?, ValueChangedEventArgs, Task>? valueChangedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.ValueChangedEvent = new AsyncEventCommand<ValueChangedEventArgs>(executeWithFullArgs: valueChangedAction, runInBackground);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Action? dragStartedAction)
        where T : ISlider
    {
        slider.DragStartedEvent = new SyncEventCommand<EventArgs>(execute: dragStartedAction);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Action<EventArgs>? dragStartedAction)
        where T : ISlider
    {
        slider.DragStartedEvent = new SyncEventCommand<EventArgs>(executeWithArgs: dragStartedAction);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Action<object?, EventArgs>? dragStartedAction)
        where T : ISlider
    {
        slider.DragStartedEvent = new SyncEventCommand<EventArgs>(executeWithFullArgs: dragStartedAction);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Func<Task>? dragStartedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragStartedEvent = new AsyncEventCommand<EventArgs>(execute: dragStartedAction, runInBackground);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Func<EventArgs, Task>? dragStartedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragStartedEvent = new AsyncEventCommand<EventArgs>(executeWithArgs: dragStartedAction, runInBackground);
        return slider;
    }

    public static T OnDragStarted<T>(this T slider, Func<object?, EventArgs, Task>? dragStartedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragStartedEvent = new AsyncEventCommand<EventArgs>(executeWithFullArgs: dragStartedAction, runInBackground);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Action? dragCompletedAction)
        where T : ISlider
    {
        slider.DragCompletedEvent = new SyncEventCommand<EventArgs>(execute: dragCompletedAction);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Action<EventArgs>? dragCompletedAction)
        where T : ISlider
    {
        slider.DragCompletedEvent = new SyncEventCommand<EventArgs>(executeWithArgs: dragCompletedAction);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Action<object?, EventArgs>? dragCompletedAction)
        where T : ISlider
    {
        slider.DragCompletedEvent = new SyncEventCommand<EventArgs>(executeWithFullArgs: dragCompletedAction);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Func<Task>? dragCompletedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragCompletedEvent = new AsyncEventCommand<EventArgs>(execute: dragCompletedAction, runInBackground);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Func<EventArgs, Task>? dragCompletedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragCompletedEvent = new AsyncEventCommand<EventArgs>(executeWithArgs: dragCompletedAction, runInBackground);
        return slider;
    }

    public static T OnDragCompleted<T>(this T slider, Func<object?, EventArgs, Task>? dragCompletedAction, bool runInBackground = false)
        where T : ISlider
    {
        slider.DragCompletedEvent = new AsyncEventCommand<EventArgs>(executeWithFullArgs: dragCompletedAction, runInBackground);
        return slider;
    }
}

public static partial class SliderStyles
{
    public static Action<ISlider>? Default { get; set; }
    public static Dictionary<string, Action<ISlider>> Themes { get; } = [];
}