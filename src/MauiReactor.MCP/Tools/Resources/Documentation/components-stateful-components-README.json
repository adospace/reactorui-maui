{
    "Key":  "components/stateful-components/README",
    "Summary":  "Components with internal state and lifecycle. Tie a component to a C# state class, update it with SetState(), and use lifecycle hooks (OnMounted, OnPropsChanged, OnWillUnmount) to load data and clean up.",
    "Remarks":  "A stateful component binds to a plain C# state class (empty constructor) to preserve data across renders. Lifecycle: OnMounted() is called when the component’s native control is first added to the page visual tree—ideal for initialization such as web service calls or local DB queries. OnPropsChanged() runs when the component is migrated between renders (same type) to react to prop changes. OnWillUnmount() is called before the component is removed from the visual tree to release resources. Updating state: call SetState(updater) to mark the component and its ancestors invalid, then MauiReactor rebuilds the visual tree. Valid components are reused; invalid ones are recreated and their Render() runs to produce updated nodes. For performance-critical paths, you can update the native control without a full component invalidation by using functional bindings (e.g., Label(() => $\"Counter: {State.Counter}\")) and SetState(..., invalidateComponent: false). Guidance: avoid constructors for inputs—expose public props instead.",
    "Example":  "// Example 1: Busy page with async initialization\r\npublic class BusyPageState\r\n{\r\n    public bool IsBusy { get; set; }\r\n}\r\n\r\npublic class BusyPageComponent : Component<BusyPageState>\r\n{\r\n    protected override void OnMounted()\r\n    {\r\n        // component just mounted: set initial state\r\n        State.IsBusy = true;\r\n\r\n        // simulate background work\r\n        Task.Run(async () =>\r\n        {\r\n            await Task.Delay(3000);\r\n            SetState(s => s.IsBusy = false);\r\n        });\r\n\r\n        base.OnMounted();\r\n    }\r\n\r\n    public override VisualNode Render()\r\n        => ContentPage(\r\n            ActivityIndicator()\r\n                .Center()\r\n                .IsRunning(State.IsBusy)\r\n        );\r\n}\r\n\r\n// Example 2: Update state without full re-render\r\nclass CounterPageState\r\n{\r\n    public int Counter { get; set; }\r\n}\r\n\r\nclass CounterPage : Component<CounterPageState>\r\n{\r\n    public override VisualNode Render()\r\n        => ContentPage(\r\n            VStack(spacing: 10,\r\n                Label(() => $\"Counter: {State.Counter}\")\r\n                    .VCenter()\r\n                    .HCenter(),\r\n\r\n                Button(\"Click To Increment\", () =>\r\n                    SetState(s => s.Counter++, invalidateComponent: false))\r\n            )\r\n            .Center()\r\n        );\r\n}\r"
}
