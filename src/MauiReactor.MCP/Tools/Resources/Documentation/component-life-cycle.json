{
  "Key": "components/component-life-cycle",
  "Summary": "Understand MauiReactor component lifecycle: `OnMounted`, `OnWillUnmount`, and `OnPropsChanged` to initialize, cleanup, and react to prop changes.",
  "Remarks": "MauiReactor components render via `Render()` into a logical tree. When the tree is invalidated (e.g., `SetState`, `Invalidate()`), components are Created, Removed, or Migrated. Use `OnMounted()` after the component is added to the tree to initialize state or kick off async work that will update state. Use `OnWillUnmount()` just before removal to unsubscribe events, dispose unmanaged resources, and cleanup. Use `OnPropsChanged()` when the component is migrated in the next render tree to react to changed props and possibly update state (often similar logic to `OnMounted`). All lifecycle methods run on the UI thread; perform expensive operations asynchronously. Keep lifecycle handlers idempotent, easy to reason about, and free of long blocking calls.",
  "Example": "partial class IncrementalCounter : Component\n{\n    [Prop] int _currentValue;\n    [Prop] private Action<int> _valueChanged;\n\n    protected override void OnMounted()\n    {\n        Debug.WriteLine(\"[IncrementalCounter] OnMounted()\");\n        // init state/resources, subscribe\n    }\n\n    protected override void OnPropsChanged()\n    {\n        Debug.WriteLine(\"[IncrementalCounter] OnPropsChanged()\");\n        // react to prop changes, maybe SetState\n    }\n\n    protected override void OnWillUnmount()\n    {\n        Debug.WriteLine(\"[IncrementalCounter] OnWillUnmount()\");\n        // cleanup, unsubscribe, dispose\n    }\n}\n\n// Sample toggling two components, triggering lifecycle transitions\nclass MainPage : Component<MainPageState>\n{\n    public override VisualNode Render() => new ContentPage\n    {\n        new VStack\n        {\n            new Button($\"Use {( !State.Toggle ? \"increment\" : \"decrement\" )} button\", () => SetState(s => s.Toggle = !s.Toggle)),\n            State.Toggle ?\n                new IncrementalCounter().CurrentValue(State.CurrentValue).ValueChanged(v => SetState(s => s.CurrentValue = v)) :\n                new DecrementalCounter().CurrentValue(State.CurrentValue).ValueChanged(v => SetState(s => s.CurrentValue = v))\n        }\n        .Center()\n    };\n}"
}